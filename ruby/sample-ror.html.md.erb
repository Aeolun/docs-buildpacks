---
title: Deploy a Sample Ruby on Rails Application
---

<strong><%= modified_date %></strong>

This topic walks the reader through deploying a sample Ruby on Rails app to <%= vars.product_full %> (CF).

The following subjects are covered:

- Using the CF CLI to target a CF deployment.
- App manifests.
- Deploying an app.
- How app URL endpoints are generated in CF.
- Adding a service instance (A postrgres database, in this example).

##<a id='prerequisites'></a>Prerequisites  

- A working CF deployment. See [Deploying CF Using BOSH-Lite](http://docs.cloudfoundry.org/deploying/boshlite/deploy_cf_boshlite.html).
- [Cloud Foundry CLI](http://docs.cloudfoundry.org/devguide/installcf/install-go-cli.html)
- Username and password with **Space Developer** [permissions](../../concepts/roles.html#space-roles).

##<a id='clone'></a>Step 1: Clone the App ##

1. Run the following in the terminal <code>git clone</code> to create a local copy. 
<pre class='terminal'>
	$ git clone https://github.com/cloudfoundry-samples/rails_sample_app
</pre>

	The newly created <code>rails\_sample\_app directory</code> contains a Ruby on Rails app with an [application manifest](../..devguide/deploy-apps/manifest.html#minimal-manifest), which assists CF with deploying the app.

	<pre class='terminal'>
	~/workspace/rails_sample_app $ ls
	Gemfile	README.markdown	app	bin	config db files <div style='display:inline;color:black;background:yellow'>manifest.yml</div> script vendor
	Gemfile.lock	Rakefile autotest bundler_stubs config.ru doc lib public spec
	</pre>

##<a id='login'></a>Step 2: Log in and Target the API Endpoint ##

1. Run the following to log in and target the API endpoint of your Cloud Foundry deployment. 

	<pre class='terminal'>$ cf login -a YOUR-API-ENDPOINT</pre>

1.	When prompted for login credentials, and to select a [Space and Org](../../concepts/roles.html). 
1. For <%= vars.api_endpoint %>, enter the IP of the BOSH director for your Cloud Foundry deployment. The IP must be entered in the following format: `http://api.IP-ADDRESS`


##<a id='service'></a>Step 3: Create a Service Instance ##

In Cloud Foundry, a database is a type of service. To add a database for our sample application, we will create an instance of [elephantsql](http://www.elephantsql.com/), a third-party database as a service provider.

1. Run the following terminal command to create a PostgreSQL service instance for our app. Our service instance is `rails-postgres`. It uses the `elephantsql` service and the `turtle` plan.

  <pre class="terminal">
  $   cf create-service elephantsql turtle rails-postgres
  Creating service rails-postgres in org YOUR-ORG / space development as clouduser@example.com....
  OK</pre>

  The manifest for the rails_sample_app contains a `services` sub-block in the `applications` block, as the example below shows. This binds the `rails-postgres` service instance you created in the previous step.
	<pre class="terminal">
	---
	applications:
	- name: rails-sample
	  memory: 256M
	  instances: 1
	  path: .
	  command: bundle exec rake db:migrate && bundle exec rails s -p $PORT
	  services:
	    - rails-postgres
	</pre>    

##<a id='deploy'></a>Step 4: Deploy the App ##

From your application's root directory, run the following in the terminal to deploy the app:
<pre class='terminal'>$ cf push rails\_sample\_app</pre>

`cf push rails_sample_app` creates a URL route to your application in the form HOST.DOMAIN, where HOST is your APP-NAME. Administrators specify your DOMAIN. For example, for the DOMAIN `<%=vars.app_domain%>`, running `cf push rails_sample_app` creates the URL `rails_sample_app.<%=vars.app_domain%>`.

If you want to view log activity while the app deploys, launch a new terminal window and run `cf logs rails_sample_app`.

The example below shows the terminal output when deploying the `rails_sample_app`. `cf push` uses the instructions in the manifest file to create the app, create and bind the route, and upload the app. It then binds the app to the `rails-postgres` service and follows the information in the manifest to start one instance of the app with of RAM. After the app starts, the output displays the health and status of the app.


<pre class="terminal">

$ cf push rails_sample_app
Using manifest file ~/workspace/rails_sample_app/manifest.yml

Updating app rails_sample_app in org Cloud-Apps / space development as clouduser@example.com...
OK

Using route rails_sample_app.<%=vars.app_domain%>
Uploading rails_sample_app...
Uploading app files from: ~/workspace/rails_sample_app
Uploading 445.7K, 217 files
OK
Binding service rails-postgres to app rails_sample_app in org Cloud-Apps / space development as clouduser@example.com...
OK

Starting app rails_sample_app in org Cloud-Apps / space development as clouduser@example.com...
OK

...

0 of 1 instances running, 1 starting
1 of 1 instances running

App started

Showing health and status for app rails_sample_app in org Cloud-Apps / space development as clouduser@example.com...
OK

requested state: started
instances: 1/1
usage: 256M x 1 instances
urls: rails_sample_app.<%=vars.app_domain%>

     state     since                    cpu    memory          disk
#0   running   2014-08-25 03:32:10 PM   0.0%   68.4M of 256M   73.4M of 1G

</pre>

##<a id='verify'></a> Step 5: Verifying the App ##

Verify the app is running by browsing to the URL generated in the output of the previous step. In this example, the url is `urls: rails_sample_app.<%=vars.app_domain%>`.


You've now pushed an app to <%=vars.product_short%>! For more information on this topic, see the [Deploy an Application](../../devguide/deploy-apps/deploy-app.html) topic.
