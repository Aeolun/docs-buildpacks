---
title: Getting Started Deploying Ruby on Rails Apps
---

<%=vars.GSG_intro_sentence%>

This guide is intended to walk you through deploying a Ruby on Rails (RoR) app to <%=vars.product_full%>. You can choose whether to push a sample app, your own app, or both.

If at any time you experience a problem following the steps below, try checking the <%=vars.known_issues%> topic, or refer to the [Troubleshooting Application Deployment and Health](./../../devguide/deploy-apps/troubleshoot-app-health.html) topic for more tips.


## <a id='deploy-yourapp'></a>Deploy Your RoR Application ##

This section describes how to deploy your RoR application to <%=vars.product_short%>.

### Prerequisites ###

* [Bundler](http://bundler.io) configured on your workstation
- (**Optional**) [Git](http://git-scm.com) configured on your workstation and a [GitHub](https://github.com) account
* Intermediate to advanced RoR knowledge
- (**Optional**) Robust production web server for Ruby and RoR apps, such as Unicorn
* Your Rails 4.x app that runs locally on your workstation

### Step 1: Add the rails_12factor Gem to Your Gemfile ###

1. Add `gem 'rails_12factor', group: :production` to your Gemfile.

    <p class="note"><strong>Note</strong>:  This gem includes the <code>rails&#095;serve&#095;static&#095;assets</code> gem that enables your Rails app to run in production with the static assets serving functionality. The <code>rails&#095;serve&#095;static&#095;assets</code> gem does this by automatically modifying the <code>config.serve&#095;static&#095;assets</code> configuration parameter from <code>false</code> to <code>true</code>. Do not change the value for this option. For more information, refer to the <a href="https://github.com/heroku/rails_12factor">Rails_12factor GitHub README</a>.</p>

1. Run `bundle install` to update your Gemfile.

### Step 2: (Optional) Configure Automatically Invoked Rake Tasks for Deployed Applications ###

<%=vars.product_short%> does not provide a way to run a Rake task on a deployed application. For <%=vars.product_short%> to automatically invoke a Rake task while an app is deployed, you must include the Rake task in your application and also configure the application start command with the `command` attribute in the application manifest, `manifest.yml`.
The following is an example of how to invoke a Rake database migration task at application startup.

1. Create a file with the Rake task name and the extension `.rake`, and store it in the `lib/tasks` directory of your application.

1. Add the following code to your rake file:

    <pre class="code">
    namespace :cf do
        desc "Only run on the first application instance"
        task :on_first_instance do
            instance_index = JSON.parse(ENV["VCAP_APPLICATION"])["instance_index"] rescue nil
        exit(0) unless instance_index == 0
        end
    end

    </pre>

    This Rake task limits an idempotent command to the first instance of a deployed application.

1. Add the task to the `manifest.yml` file with the `command` attribute, referencing the idempotent command `rake db:migrate` chained with a start command.

    <pre class="code">
applications:
 &#8208; name: my-rails-app
 command: bundle exec rake cf:on_first_instance db:migrate && rails s -p $PORT

    </pre>

### Step 3: Create and Bind a Service Instance for Your RoR Application ###

This section describes using the CLI to configure a PostgreSQL managed service instance for your app. <%=vars.dev_console_1%>

<%=vars.product_short%> supports two types of service instances:

* Managed services integrate with <%=vars.product_short%> through service brokers that offer services and plans and manage the service calls between <%=vars.product_short%> and a service provider.
* User-provided service instances enable you to connect your application to pre-provisioned external service instances.

For more information on creating and using service instances, refer to the [Services Overview](./../../devguide/services/index.html) topic.

#### Create a Service Instance ####

Run `cf marketplace` to view managed and user-provided services and plans available to you.

The example shows three of the available managed database-as-a-service providers and their offered plans: `cleardb` MySQL, `elephantsql` PostgreSQL as a Service, and `mongolab` MongoDB-as-a-Service.

<pre class="terminal">

$  cf marketplace
Getting services from marketplace in org Cloud-Apps / space development as clouduser@example.com...
OK


service          plans 	description

...
cleardb          spark, boost, amp, shock  	Highly available MySQL for your Apps

...
elephantsql      turtle, panda, hippo, elephant   PostgreSQL as a Service
...
mongolab         sandbox   	Fully-managed MongoDB-as-a-Service
...
</pre>

Run `cf create-service [SERVICE] [PLAN] [SERVICE_INSTANCE]` to create a service instance for your app. Choose a SERVICE and PLAN from the list, and provide a unique name for the SERVICE_INSTANCE.

The example shows creating a service instance named `rails-postgres` that uses the `elephantsql` service and the `turtle` plan.

<pre class="terminal">

$   cf create-service elephantsql turtle rails-postgres
Creating service rails-postgres in org Cloud-Apps / space development as clouduser@example.com....
OK

</pre>

#### Bind a Service Instance ####

When you bind an app to a service instance, <%=vars.product_short%> writes information about the service instance to the VCAP_SERVICES app environment variable. The app can use this information to integrate with the service instance.

Most services support bindable service instances. Refer to your service provider's documentation to confirm if they support this functionality.

You can bind a service to an application with the command `cf bind-service APPLICATION SERVICE_INSTANCE`.

For example, to bind the `rails-postgres` service that we created in the previous example:

<pre class="terminal">
$ cf bind-service my-rails-app rails-postgres
</pre>

Alternately, you can configure the deployment manifest file by adding a `services` block to the `applications` block and specifying the service instance. For more information, see the next step.

<%=vars.dev_console_5%>

### Step 4: Configure the Manifest File  ###

You can specify app deployment options in a manifest that the `cf push` command uses. For more information about application manifests and supported attributes, refer to the [Deploying with Application Manifests](./../../devguide/deploy-apps/manifest.html) topic.

### Step 5: Log in and Target the API Endpoint   ###
Run `cf login -a [API_ENDPOINT]`, enter your login credentials, and select a space and org. The API endpoint is <%=vars.api_endpoint%>.

<%=vars.gen_GSG%>


### Step 6: (Optional) Configure a Production Server  ###

<%=vars.product_short%> uses the default standard Ruby web server library WEBrick for Ruby and RoR apps. However, <%=vars.product_short%> can support a more robust production web server, such as Phusion Passenger, Puma, Thin, or Unicorn.

To instruct <%=vars.product_short%> to use a web server other than WEBrick, you configure a text file called a _Procfile_. A Procfile enables you to declare required runtime processes, called _process_ _types_, for your web app. Process managers in a server use the process types to run and manage the workload.

When you deploy, <%=vars.product_short%> determines if a Procfile exists and uses the Procfile to configure your app with the specified production web server settings.

In a Procfile, you declare one process type per line and use the following syntax, as shown in the example below:

* `PROCESS_TYPE` is the command name in the format of an alphanumeric string. Specifically for RoR web apps, you can declare `web` and `worker` process types.
* `COMMAND` is the command line to launch the process.

Example process type syntax:
    <pre class="code">
    PROCESS_TYPE: COMMAND
    </pre>

To set a different production web server for your app:

1. Add the gem for the web server to your Gemfile. 

1. (**Optional**) In the `config/` directory of your app, create a new configuration file or modify an existing file.

    Refer to your web server documentation for how to configure this file.

    Example Puma config file:
    <pre class="code">
    &#35; config/puma.rb
    threads 8,32
    workers 3

    on\_worker\_boot do
      # things workers do
    end
    </pre>

1. In the root directory of your app, create a Procfile and add a command line for a `web` process type that points to your web server. 

    The example below shows a command that starts a Puma web server and specifies the app runtime environment, TCP port, and paths to the server state information and configuration files.
    Refer to your web server documentation for how to configure the specific command for a process type.

    Example Procfile:
    <pre class="code">
    web: bundle exec puma -e $RAILS_ENV -p 1234 -S ~/puma -C config/puma.rb
    </pre>

### Step 7: Deploy Your Application ###
When you deploy your application, `cf push`:

 * Creates a URL that is the route to your application. The URL is in the form HOST.DOMAIN, where HOST is the APP_NAME and DOMAIN is specified by your administrator. Your DOMAIN is`<%=vars.app_domain%>`.

 * Searches for an application manifest YAML file. A manifest specifies what `cf push` should do with the app.
 * Determines the appropriate buildpack for the app. A buildpack provides framework and runtime support for your app.

<p class="note"><strong>Note</strong>: You must use the CLI to deploy apps.</p>

For example: `cf push my-app` creates the URL `my-app.<%=vars.app_domain%>`.

1. `cd` to the app directory that you want to deploy.
1. Run `cf push [APP-NAME]`.

    The URL for your app must be unique from other apps that <%=vars.product_short%> hosts or the push will fail. You can use the following options to create a unique URL:
    * `-n` to assign a different HOST name for the app.
    * `--random-route` to create a URL that includes the app name and random words.
    * Run `cf help push` to view other options for this command.

1. Launch a new terminal window and run `cf logs [APP-NAME]` to simultaneously view log activity while the app deploys.
1. Browse to your app URL.

    Search for the `urls` field in the `App started` block in the output of the `cf push` command. Use the URL to access your app online.

    <pre class="terminal">

    App started

    Showing health and status for app rails_sample_app in org Cloud-Apps / space development as clouduser@example.com...
    OK

    requested state: started
    instances: 1/1
    usage: 256M x 1 instances
    urls: jmt0814-rails.<%=vars.app_domain%>


         state     since                    cpu    memory        disk
    #0   running   2014-08-13 02:45:51 PM   0.0%   69M of 256M   72.7M of 1G
    </pre>

## <a id='deploy-sample'></a>Deploy a RoR Sample Application ##

This section describes how to deploy a RoR sample application named `rails_sample_app`.

To learn how to deploy your own RoR app, see [Deploy Your RoR Application](#deploy-yourapp).

### Prerequisites ###

* [Git](http://git-scm.com) configured on your workstation and a [GitHub](https://github.com) account
* Basic RoR knowledge

### Step 1: Get a Sample RoR App from GitHub ###

Run `git clone https://github.com/cloudfoundry-samples/rails_sample_app` to clone `rails_sample_app` from GitHub.

### Step 2: Log in and Target the API Endpoint   ###

Run `cf login -a [API_ENDPOINT]`, enter your login credentials, and select a space and org. The API endpoint is <%=vars.api_endpoint%>.

### Step 3: Deploy the Sample App ###

1. `cd` to the cloned app directory.
1. Run `cf create-service elephantsql turtle rails-postgres`.
1. Run `cf push rails_sample_app -n [HOST_NAME]`.

Example: `cf push rails_sample_app -n jc0825-rails`

`cf push [APP_NAME]` pushes the specified app from the current directory to <%=vars.product_short%>. Use the `-n` flag to create a unique host name for the app to avoid URL collisions with other apps.

`cf push` automatically searches for an [application manifest YAML file](./../../devguide/deploy-apps/manifest.html) (`manifest.yml`) and also determines the appropriate [buildpack](./index.html) for the app.  A manifest specifies what `cf push` should do with the app and the buildpack provides framework and runtime support for your app.

The example shows the terminal output of deploying the `rails_sample_app`. `cf push` uses the instructions in the manifest file to create the app, create and bind and the route, and upload the app to <%=vars.product_short%>. It then binds the app to the `rails-postgres` service you defined in the previous step, and follows the instructions in the manifest to start one instance of the app with 256M. After the app starts, the output displays the health and status of the app.

<pre class="terminal">

	$ cf push rails_sample_app -n jmt2014-rails
	Using manifest file /Users/pivotal/workspace/rails_sample_app/manifest.yml

	Updating app rails_sample_app in org Cloud-Apps / space development as clouduser@example.com...
	OK

	Using route jmt2014-rails.<%=vars.app_domain%>
	Uploading rails_sample_app...
	Uploading app files from: /Users/pivotal/workspace/rails_sample_app
	Uploading 445.7K, 217 files
	OK
	Binding service rails-postgres to app rails_sample_app in org Cloud-Apps / space development as clouduser@example.com...
	OK

	Starting app rails_sample_app in org Cloud-Apps / space development as clouduser@example.com...
	OK

	...

	0 of 1 instances running, 1 starting
	1 of 1 instances running

	App started

	Showing health and status for app rails_sample_app in org Cloud-Apps / space development as clouduser@example.com...
	OK

	requested state: started
	instances: 1/1
	usage: 256M x 1 instances
	urls: jmt2014-rails.<%=vars.app_domain%>

	     state     since                    cpu    memory          disk
	#0   running   2014-08-25 03:32:10 PM   0.0%   68.4M of 256M   73.4M of 1G

</pre>

### Step 4: Test the Sample App ###

You’ve deployed your first app to <%=vars.product_short%>! Now let’s access your app online using its URL.
In the terminal output, the `urls` field of the `App started` block contains the app URL. This is the `HOST_NAME` you specified with the `-n` flag plus the domain `<%=vars.app_domain%>`. The image shows the resulting webpage for the `rails_sample_app`.

<%= image_tag("../images/RoR_sample_webpage.png") %>

You can now use the `cf` <%=vars.dev_console_2%> to review information and administer your app and your <%=vars.product_short%> account. For example, you could edit the `rails_sample_app/manifest.yml` to increase the number of app instances from 1 to 3, and redeploy the app with a new app name and host name.

See the [Manage Your Application with the cf CLI](#cli-manage) section for more information. <%=vars.dev_console_4%>


## <a id='cli-manage'></a>Manage Your Application with the cf CLI ##

Run `cf help` to view a complete list of commands, grouped by task categories, and run `cf help [COMMAND]` for detailed information about a specific command. For more information about using the `cf` CLI, refer to the cf Command Line Interface (CLI) topics, especially the <%=vars.cli_v6%> topic.

<p class="note"><strong>Note</strong>: You cannot perform certain tasks in the <%=vars.dev_console_2%> because these are commands that only a <%=vars.product_short%> administrator can run. If you are not a <%=vars.product_short%> administrator, the following message displays for these types of commands:

<code>error code: 10003, message: You are not authorized to perform the requested action</code>

<%=vars.dev_console_note%>
</p>

## <a id='troubleshoot'></a>Troubleshooting ##
If your application fails to start, verify that the application starts in your local environment. Refer to the [Troubleshooting Application Deployment and Health](./../../devguide/deploy-apps/troubleshoot-app-health.html) topic to learn more about troubleshooting.

### App Deploy Fails ###
Even when the deploy fails, the app might exist on <%=vars.product_short%>. Run `cf apps` to review the apps in the currently targeted org and space. You might be able to correct the issue using the <%=vars.dev_console_2%>, or you might have to delete the app and redeploy.

Common reasons deploying an app fails include:

* You did not successfully create and bind a needed service instance to the app, such as a PostgreSQL or MongoDB service instance. Refer to Step 3: Configure a Service Instance for Your RoR Application.
* You did not successfully create a unique URL for the app. Refer to the troubleshooting tip App Requires Unique URL.

### App Requires Unique URL ###
<%=vars.product_short%> requires that each app that you deploy have a unique URL. Otherwise, the new app URL collides with an existing app URL and <%=vars.product_short%> cannot successfully deploy the app. You can fix this issue by running `cf push` with either of the following flags to create a unique URL:

* `-n` to assign a different HOST name for the app.
* `--random-route` to create a URL that includes the app name and random words. Using this option might create a long URL, depending on the number of words that the app name includes.






